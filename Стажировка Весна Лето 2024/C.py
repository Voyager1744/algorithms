"""
C. Пересекающиеся отрезки
Ограничение времени	1 секунда
Ограничение памяти	256.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Даны два массива
a
a и
b
b длины
N
N из целых чисел. Рассмотрим множество, состоящее из отрезков, соединяющих точки
(
0
,
a
i
)
(0,a
i
​
 ) и
(
1
,
b
i
)
(1,b
i
​
 ) для
1
≤
i
≤
N
1≤i≤N. Найдите количество отрезков этого множества, которые не пересекаются с другими отрезками.

Например, если
a
=
[
1
,
2
,
3
,
4
,
5
]
a=[1,2,3,4,5] и
b
=
[
4
,
5
,
1
,
5
,
6
]
b=[4,5,1,5,6], получатся следующие отрезки:

Логотип markdown

Обратите внимание, что пересекающимися считаются отрезки, имеющие хотя бы одну общую точку. То есть отрезки, имеющие одинаковый конец, пересекаются. Например, на картинке отрезки, заданные точками
[
(
0
,
2
)
,
(
1
,
5
)
]
[(0,2),(1,5)] и
[
(
0
,
4
)
,
(
1
,
5
)
]
[(0,4),(1,5)] считаются пересекающимися.

Формат ввода
В первой строке ввода находится единственное число
N
N (
1
≤
N
≤
3
⋅
1
0
5
1≤N≤3⋅10
5
 ) — количество отрезков.

В следующих
N
N строках находится по два целых числа, разделенных пробелом —
a
i
a
i
​
  и
b
i
b
i
​
  (
1
≤
a
i
,
b
i
≤
2
⋅
N
1≤a
i
​
 ,b
i
​
 ≤2⋅N), задающие координаты
i
i-го отрезка.

Гарантируется, что все отрезки, заданные во вводе различны, то есть при
i
≠
j
i

=j выполнено не менее одного из условий
a
i
≠
a
j
a
i
​


=a
j
​
  и
b
i
≠
b
j
b
i
​


=b
j
​
 .

Формат вывода
Выведите единственное число — количество отрезков, которые не пересекаются с другими.
"""


N = int(input())
segments = []
for _ in range(N):
    a, b = map(int, input().split())
    segments.append((a, b))


segments.sort(key=lambda x: x[0])


count_non_intersecting = 1
end = segments[0][1]

for i in range(1, N):
    if segments[i][0] > end:
        count_non_intersecting += 1
        end = segments[i][1]
    else:
        end = max(end, segments[i][1])

print(count_non_intersecting)
